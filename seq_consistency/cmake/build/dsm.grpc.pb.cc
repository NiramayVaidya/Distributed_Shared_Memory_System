// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: dsm.proto

#include "dsm.pb.h"
#include "dsm.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace dsm {

static const char* Poll_method_names[] = {
  "/dsm.Poll/poll",
};

std::unique_ptr< Poll::Stub> Poll::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Poll::Stub> stub(new Poll::Stub(channel, options));
  return stub;
}

Poll::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_poll_(Poll_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Poll::Stub::poll(::grpc::ClientContext* context, const ::dsm::PollRequest& request, ::dsm::PollReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::dsm::PollRequest, ::dsm::PollReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_poll_, context, request, response);
}

void Poll::Stub::async::poll(::grpc::ClientContext* context, const ::dsm::PollRequest* request, ::dsm::PollReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::dsm::PollRequest, ::dsm::PollReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_poll_, context, request, response, std::move(f));
}

void Poll::Stub::async::poll(::grpc::ClientContext* context, const ::dsm::PollRequest* request, ::dsm::PollReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_poll_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dsm::PollReply>* Poll::Stub::PrepareAsyncpollRaw(::grpc::ClientContext* context, const ::dsm::PollRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::dsm::PollReply, ::dsm::PollRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_poll_, context, request);
}

::grpc::ClientAsyncResponseReader< ::dsm::PollReply>* Poll::Stub::AsyncpollRaw(::grpc::ClientContext* context, const ::dsm::PollRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncpollRaw(context, request, cq);
  result->StartCall();
  return result;
}

Poll::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Poll_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Poll::Service, ::dsm::PollRequest, ::dsm::PollReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Poll::Service* service,
             ::grpc::ServerContext* ctx,
             const ::dsm::PollRequest* req,
             ::dsm::PollReply* resp) {
               return service->poll(ctx, req, resp);
             }, this)));
}

Poll::Service::~Service() {
}

::grpc::Status Poll::Service::poll(::grpc::ServerContext* context, const ::dsm::PollRequest* request, ::dsm::PollReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* RegDataSeg_method_names[] = {
  "/dsm.RegDataSeg/regDataSeg",
};

std::unique_ptr< RegDataSeg::Stub> RegDataSeg::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< RegDataSeg::Stub> stub(new RegDataSeg::Stub(channel, options));
  return stub;
}

RegDataSeg::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_regDataSeg_(RegDataSeg_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status RegDataSeg::Stub::regDataSeg(::grpc::ClientContext* context, const ::dsm::RegRequest& request, ::dsm::RegReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::dsm::RegRequest, ::dsm::RegReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_regDataSeg_, context, request, response);
}

void RegDataSeg::Stub::async::regDataSeg(::grpc::ClientContext* context, const ::dsm::RegRequest* request, ::dsm::RegReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::dsm::RegRequest, ::dsm::RegReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_regDataSeg_, context, request, response, std::move(f));
}

void RegDataSeg::Stub::async::regDataSeg(::grpc::ClientContext* context, const ::dsm::RegRequest* request, ::dsm::RegReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_regDataSeg_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dsm::RegReply>* RegDataSeg::Stub::PrepareAsyncregDataSegRaw(::grpc::ClientContext* context, const ::dsm::RegRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::dsm::RegReply, ::dsm::RegRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_regDataSeg_, context, request);
}

::grpc::ClientAsyncResponseReader< ::dsm::RegReply>* RegDataSeg::Stub::AsyncregDataSegRaw(::grpc::ClientContext* context, const ::dsm::RegRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncregDataSegRaw(context, request, cq);
  result->StartCall();
  return result;
}

RegDataSeg::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RegDataSeg_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RegDataSeg::Service, ::dsm::RegRequest, ::dsm::RegReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RegDataSeg::Service* service,
             ::grpc::ServerContext* ctx,
             const ::dsm::RegRequest* req,
             ::dsm::RegReply* resp) {
               return service->regDataSeg(ctx, req, resp);
             }, this)));
}

RegDataSeg::Service::~Service() {
}

::grpc::Status RegDataSeg::Service::regDataSeg(::grpc::ServerContext* context, const ::dsm::RegRequest* request, ::dsm::RegReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* DirUpd_method_names[] = {
  "/dsm.DirUpd/dirUpd",
};

std::unique_ptr< DirUpd::Stub> DirUpd::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< DirUpd::Stub> stub(new DirUpd::Stub(channel, options));
  return stub;
}

DirUpd::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_dirUpd_(DirUpd_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status DirUpd::Stub::dirUpd(::grpc::ClientContext* context, const ::dsm::UpdRequest& request, ::dsm::UpdReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::dsm::UpdRequest, ::dsm::UpdReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_dirUpd_, context, request, response);
}

void DirUpd::Stub::async::dirUpd(::grpc::ClientContext* context, const ::dsm::UpdRequest* request, ::dsm::UpdReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::dsm::UpdRequest, ::dsm::UpdReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_dirUpd_, context, request, response, std::move(f));
}

void DirUpd::Stub::async::dirUpd(::grpc::ClientContext* context, const ::dsm::UpdRequest* request, ::dsm::UpdReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_dirUpd_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dsm::UpdReply>* DirUpd::Stub::PrepareAsyncdirUpdRaw(::grpc::ClientContext* context, const ::dsm::UpdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::dsm::UpdReply, ::dsm::UpdRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_dirUpd_, context, request);
}

::grpc::ClientAsyncResponseReader< ::dsm::UpdReply>* DirUpd::Stub::AsyncdirUpdRaw(::grpc::ClientContext* context, const ::dsm::UpdRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncdirUpdRaw(context, request, cq);
  result->StartCall();
  return result;
}

DirUpd::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DirUpd_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DirUpd::Service, ::dsm::UpdRequest, ::dsm::UpdReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DirUpd::Service* service,
             ::grpc::ServerContext* ctx,
             const ::dsm::UpdRequest* req,
             ::dsm::UpdReply* resp) {
               return service->dirUpd(ctx, req, resp);
             }, this)));
}

DirUpd::Service::~Service() {
}

::grpc::Status DirUpd::Service::dirUpd(::grpc::ServerContext* context, const ::dsm::UpdRequest* request, ::dsm::UpdReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* Invalidate_method_names[] = {
  "/dsm.Invalidate/invalidate",
};

std::unique_ptr< Invalidate::Stub> Invalidate::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Invalidate::Stub> stub(new Invalidate::Stub(channel, options));
  return stub;
}

Invalidate::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_invalidate_(Invalidate_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Invalidate::Stub::invalidate(::grpc::ClientContext* context, const ::dsm::InvalidateRequest& request, ::dsm::InvalidateReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::dsm::InvalidateRequest, ::dsm::InvalidateReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_invalidate_, context, request, response);
}

void Invalidate::Stub::async::invalidate(::grpc::ClientContext* context, const ::dsm::InvalidateRequest* request, ::dsm::InvalidateReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::dsm::InvalidateRequest, ::dsm::InvalidateReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_invalidate_, context, request, response, std::move(f));
}

void Invalidate::Stub::async::invalidate(::grpc::ClientContext* context, const ::dsm::InvalidateRequest* request, ::dsm::InvalidateReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_invalidate_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dsm::InvalidateReply>* Invalidate::Stub::PrepareAsyncinvalidateRaw(::grpc::ClientContext* context, const ::dsm::InvalidateRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::dsm::InvalidateReply, ::dsm::InvalidateRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_invalidate_, context, request);
}

::grpc::ClientAsyncResponseReader< ::dsm::InvalidateReply>* Invalidate::Stub::AsyncinvalidateRaw(::grpc::ClientContext* context, const ::dsm::InvalidateRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncinvalidateRaw(context, request, cq);
  result->StartCall();
  return result;
}

Invalidate::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Invalidate_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Invalidate::Service, ::dsm::InvalidateRequest, ::dsm::InvalidateReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Invalidate::Service* service,
             ::grpc::ServerContext* ctx,
             const ::dsm::InvalidateRequest* req,
             ::dsm::InvalidateReply* resp) {
               return service->invalidate(ctx, req, resp);
             }, this)));
}

Invalidate::Service::~Service() {
}

::grpc::Status Invalidate::Service::invalidate(::grpc::ServerContext* context, const ::dsm::InvalidateRequest* request, ::dsm::InvalidateReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* GetLatest_method_names[] = {
  "/dsm.GetLatest/getLatest",
};

std::unique_ptr< GetLatest::Stub> GetLatest::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< GetLatest::Stub> stub(new GetLatest::Stub(channel, options));
  return stub;
}

GetLatest::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_getLatest_(GetLatest_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status GetLatest::Stub::getLatest(::grpc::ClientContext* context, const ::dsm::LatestRequest& request, ::dsm::LatestReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::dsm::LatestRequest, ::dsm::LatestReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getLatest_, context, request, response);
}

void GetLatest::Stub::async::getLatest(::grpc::ClientContext* context, const ::dsm::LatestRequest* request, ::dsm::LatestReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::dsm::LatestRequest, ::dsm::LatestReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getLatest_, context, request, response, std::move(f));
}

void GetLatest::Stub::async::getLatest(::grpc::ClientContext* context, const ::dsm::LatestRequest* request, ::dsm::LatestReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getLatest_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dsm::LatestReply>* GetLatest::Stub::PrepareAsyncgetLatestRaw(::grpc::ClientContext* context, const ::dsm::LatestRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::dsm::LatestReply, ::dsm::LatestRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getLatest_, context, request);
}

::grpc::ClientAsyncResponseReader< ::dsm::LatestReply>* GetLatest::Stub::AsyncgetLatestRaw(::grpc::ClientContext* context, const ::dsm::LatestRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetLatestRaw(context, request, cq);
  result->StartCall();
  return result;
}

GetLatest::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      GetLatest_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< GetLatest::Service, ::dsm::LatestRequest, ::dsm::LatestReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](GetLatest::Service* service,
             ::grpc::ServerContext* ctx,
             const ::dsm::LatestRequest* req,
             ::dsm::LatestReply* resp) {
               return service->getLatest(ctx, req, resp);
             }, this)));
}

GetLatest::Service::~Service() {
}

::grpc::Status GetLatest::Service::getLatest(::grpc::ServerContext* context, const ::dsm::LatestRequest* request, ::dsm::LatestReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* FetchLatest_method_names[] = {
  "/dsm.FetchLatest/fetchLatest",
};

std::unique_ptr< FetchLatest::Stub> FetchLatest::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< FetchLatest::Stub> stub(new FetchLatest::Stub(channel, options));
  return stub;
}

FetchLatest::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_fetchLatest_(FetchLatest_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status FetchLatest::Stub::fetchLatest(::grpc::ClientContext* context, const ::dsm::FetchRequest& request, ::dsm::FetchReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::dsm::FetchRequest, ::dsm::FetchReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_fetchLatest_, context, request, response);
}

void FetchLatest::Stub::async::fetchLatest(::grpc::ClientContext* context, const ::dsm::FetchRequest* request, ::dsm::FetchReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::dsm::FetchRequest, ::dsm::FetchReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_fetchLatest_, context, request, response, std::move(f));
}

void FetchLatest::Stub::async::fetchLatest(::grpc::ClientContext* context, const ::dsm::FetchRequest* request, ::dsm::FetchReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_fetchLatest_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::dsm::FetchReply>* FetchLatest::Stub::PrepareAsyncfetchLatestRaw(::grpc::ClientContext* context, const ::dsm::FetchRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::dsm::FetchReply, ::dsm::FetchRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_fetchLatest_, context, request);
}

::grpc::ClientAsyncResponseReader< ::dsm::FetchReply>* FetchLatest::Stub::AsyncfetchLatestRaw(::grpc::ClientContext* context, const ::dsm::FetchRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncfetchLatestRaw(context, request, cq);
  result->StartCall();
  return result;
}

FetchLatest::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      FetchLatest_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< FetchLatest::Service, ::dsm::FetchRequest, ::dsm::FetchReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](FetchLatest::Service* service,
             ::grpc::ServerContext* ctx,
             const ::dsm::FetchRequest* req,
             ::dsm::FetchReply* resp) {
               return service->fetchLatest(ctx, req, resp);
             }, this)));
}

FetchLatest::Service::~Service() {
}

::grpc::Status FetchLatest::Service::fetchLatest(::grpc::ServerContext* context, const ::dsm::FetchRequest* request, ::dsm::FetchReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace dsm

